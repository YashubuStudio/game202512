# スキル（特殊技能）システム仕様 v0.1（ターン処理へ統合）

## 1) 目的

* ユニットに任意のスキルを持たせ、戦術の幅を増やす
* ただし、同時入力・決定性・短時間（30T/1T=20〜60s）を壊さない

---

## 2) スキルの基本構造（データモデル）

各ユニットは **0個以上**のスキルを持てる。

スキルは以下を持つ：

* `skill_id`：識別子
* `trigger`：発動タイミング（後述）
* `chance`：発動確率（0〜1）または固定発動（1）
* `condition`：発動条件（例：HP%以下、城にいる、戦闘中など）
* `effect`：効果（例：回復、ダメージ増減、召喚補助、回復/強化短縮など）
* `cooldown`：再発動までのターン数（任意、0なら無し）
* `priority`：同タイミング内の解決順（小さいほど先）

> **決定性**のため、確率判定は必ず
> `seed + match_id + turn + phase + unit_id + skill_id + event_index`
> から導く乱数で行う（実装側ルール）。

---

## 3) 発動タイミング（あなたの要望を形式化）

「各フェーズのはじめと終わり」＝ **Trigger Point** を固定します。

### 3.1 フェーズとトリガー点

各ターンで、以下のトリガーを必ず呼ぶ：

* `START:Start`

* `END:Start`

* `START:Input`

* `END:Input`

* `START:Move`

* `END:Move`

* `START:Battle`

* `END:Battle`

* `START:Summon`

* `END:Summon`

* `START:End`

* `END:End`

> v0.1では「Input中に効果が出る」スキルは荒れやすいので、
> スキルの種類ごとに許可トリガーを制限する（後述）。

---

## 4) スキル判定の実行方法（決定性・公平性）

### 4.1 判定対象ユニット

各トリガー点で、**盤面に存在する全ユニット**（退場中を除く）に対して判定する。

* 退場中（respawn待ち）は判定しない
* 強化中（train中）は **判定はするが、攻撃/防衛に絡む効果は禁止**（効果カテゴリで制御）

### 4.2 判定順序（超重要）

トリガー点ごとに、判定順を固定：

1. **ユニットを unit_id 昇順**で並べる（決定性）
2. 各ユニットについて、該当トリガーのスキルを

   * `priority` 昇順
   * `skill_id` 昇順
     で処理
3. 各スキルで：

   * `cooldown` チェック
   * `condition` チェック
   * `chance` 判定（seed派生）
   * 発動なら `effect` を適用

---

## 5) 効果の適用ルール（衝突対策）

スキル効果は「いつ適用されるか」でバグりやすいので、v0.1は二層化します。

### 5.1 即時効果（Immediate）

* HP増減
* タイマー増減（回復/強化/復活の残りターンに +1/-1）
* 旗印（状態異常）付与：`stun`、`jam`、`shield` など

→ その場で即時適用して良い

### 5.2 遅延予約（Scheduled）

* 「次のMoveフェーズ開始時に〜」
* 「このターンのBattleフェーズ終了時に〜」

→ `scheduled_effects` に積んで、指定トリガーで確実に発火

> これで「途中で順序が変わって挙動が揺れる」問題を抑えます。

---

## 6) v0.1で許可するスキルカテゴリ（安全に広げる）

Input周辺や戦闘に直結するスキルは強すぎたり不具合が出やすいので、v0.1はカテゴリで制限します。

### 6.1 経済・時間差系（おすすめ）

* 回復タイマーを -1（ただし最低0）
* 強化タイマーを -1
* 召喚コストの一部返還（次ターンのみ有効）
* 産出+（そのターンのみ）

### 6.2 戦闘補助系（v0.1は控えめに）

* 自分の受けるダメージ -1（最低0）
* 相手のダメージ倍率を 1段階下げる（2→1、1→0）※ただし「戦力優位突破」は別判定
* 先制（Battle START時に1回だけ追加攻撃）※ログが増えるので注意

### 6.3 移動・制圧系

* Move START時に「このターンだけ移動距離+1」（※マップ仕様次第）
* 占領時に追加の金/資源（小）

### 6.4 禁止（v0.1では入れない）

* Inputフェーズで相手のコマンド内容を書き換える
* 盤面全体に影響する超広域スキル（テンポ崩壊）
* ランダム対象選択が多段に絡むもの（決定性が複雑化）

---

## 7) ターン処理への統合（最終フロー）

各フェーズはこうなります（※★がスキル判定ポイント）：

1. Start

   * ★START:Start（スキル）
   * 遅延タイマー更新（回復/強化/復活）
   * 完了処理（全回復/強化完了/復活配置）
   * ★END:Start（スキル）

2. Input

   * ★START:Input（スキル：基本は情報系/軽微のみ推奨）
   * 入力受付（同時）
   * ★END:Input（スキル）

3. Move

   * ★START:Move（スキル）
   * 低HP順に移動（同値seed）
   * 衝突で戦闘キューに登録
   * ★END:Move（スキル）

4. Battle

   * ★START:Battle（スキル）
   * 戦闘キュー処理（低HP順攻撃）
   * 退場処理・復活タイマー設定
   * ★END:Battle（スキル）

5. Summon

   * ★START:Summon（スキル）
   * 召喚予約を実行（移動後に出現）
   * スタック合流（最大5）
   * ★END:Summon（スキル）

6. End

   * ★START:End（スキル）
   * 勝利条件判定
   * ログ保存
   * ★END:End（スキル）

---

## 8) 最低限決めたいスキルデータ形式（JSON例）

```json
{
  "skill_id": "train_fast_1",
  "trigger": "START:Start",
  "chance": 0.25,
  "condition": { "self_status": "training" },
  "effect": { "kind": "decrease_timer", "target": "self", "timer": "train", "value": 1 },
  "cooldown": 0,
  "priority": 10
}
```

---

## 9) 追加で“必ず”必要になる設計（v0.1最小）

スキルを入れると、必須で以下をStateに持つ必要があります：

* `unit.statuses`（training/healing 等）
* `unit.cooldowns`（skill_id→remaining）
* `scheduled_effects`（発火待ち効果）
* `rng_event_index`（ログ用：乱数消費の追跡）

---
