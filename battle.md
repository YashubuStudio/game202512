# 戦闘およびターン処理システム仕様 v0.1（確定）

---

## 0. 基本前提（再確認）

* 最大 **30ターン** 以内決着
* 各ターンは **同時入力**
* 1ターン入力時間：**20秒〜60秒**
* 戦力＝**現在HP**
* 攻撃力・防御力の概念は存在しない
* ダメージは **固定値＋兵種相性**
* 行動順は **戦力（HP）の低い順**
* 強化中ユニットは **防衛・戦闘に参加しない**

---

## 1. ターン全体フロー（確定）

1ターンは以下の **5フェイズ** で構成される。

```
Start
↓
Input（同時）
↓
Move
↓
Battle
↓
Summon / End
```

---

## 2. Startフェイズ（状態更新）

このフェイズでは **プレイヤー入力を伴わない内部処理のみ**を行う。

### 2.1 ターン開始処理

* ターン番号を +1
* 勝利済みなら処理を行わず終了

### 2.2 遅延処理カウント更新

以下のカウントを **-1** する：

* 回復中ユニット（heal_timer）
* 強化中ユニット（train_timer）
* 復活待ちユニット（respawn_timer）

### 2.3 遅延処理の完了判定

* `heal_timer == 0`
  → HPを **max_hp まで全回復**
* `train_timer == 0`
  → 強化完了、行動可能状態へ
* `respawn_timer == 0`
  → 城に復活（HP全快）

---

## 3. Inputフェイズ（同時入力）

### 3.1 入力内容

プレイヤーは同時に以下を指定できる：

* ユニット（スタック）の移動先
* 回復開始（町・港・商店）
* 強化開始（城）
* 召喚予約（城・兵種指定）

### 3.2 入力制約

* 期限：20〜60秒
* 期限切れ：

  * **前ターンの入力をそのまま継続**

### 3.3 入力の扱い

* 入力は「意図」として保存
* 実際の行動可否は **Move / Battle フェイズで判定**

---

## 4. Moveフェイズ（移動処理）

### 4.1 行動順の決定

* **戦力（現在HP）の小さいユニットから**
* 同値の場合：**乱数（seed固定）**

※ 行動順は **ユニット単位**
※ スタックは内部的に「先頭ユニットのHP」を代表値としてもよい

---

### 4.2 移動処理

* 行動順に 1 ユニットずつ移動を処理
* 移動先が敵ユニットの存在するマスの場合：

  * **即座に戦闘を発生させる**
* 移動不可（強化中など）の場合：

  * 移動はスキップ

---

## 5. Battleフェイズ（戦闘処理）

### 5.1 戦闘発生条件

* 移動により **敵ユニットと同一マスに存在**
* 戦闘は **マス単位** で発生
* 同一マスで複数回の戦闘が発生し得る

---

### 5.2 戦闘1回の定義（確定）

* **戦闘とは「1ユニットが1回攻撃する処理」**
* 戦闘は以下の順で処理される：

#### 5.2.1 攻撃順

* **戦力（HP）の小さいユニットから攻撃**
* 同値は seed 依存で決定

#### 5.2.2 攻撃対象選択

* 敵スタック内の

  * **HPが最も低いユニット**
  * 同値はユニットID順

---

### 5.3 ダメージ計算（確定）

#### 5.3.1 基本ダメージ

* `BASE_DMG`（例：2）

#### 5.3.2 兵種相性倍率

| 関係      | 倍率 |
| ------- | -- |
| 有利      | ×2 |
| 等倍      | ×1 |
| 不利      | ×0 |
| Neutral | ×1 |

#### 5.3.3 戦力優位突破ルール

* 本来不利（×0）の場合でも：

  * **攻撃側スタック総HP > 防御側スタック総HP**
  * のとき倍率を **×1** に昇格

#### 5.3.4 最終ダメージ

```
damage = BASE_DMG × multiplier
```

---

### 5.4 ダメージ適用

* 対象ユニットの HP を減算
* HP ≤ 0 の場合：

  * **即退場**
  * 復活タイマーを設定

---

## 6. 退場・復活処理

### 6.1 退場

* HP ≤ 0 → 盤面から除去

### 6.2 復活ターン数

```
respawn_turns = 2 + max_hp
```

* 強ユニットほど復帰が遅い

### 6.3 復活位置

* 自軍の最寄り城
* 城が無い場合：初期城

---

## 7. Summonフェイズ（召喚処理）

### 7.1 召喚条件

* 占領中の城マス
* 事前に兵種指定済み
* 金・資源を支払い済み

### 7.2 召喚タイミング

* **移動・戦闘がすべて終わった後**
* 新ユニットを盤面に配置

### 7.3 スタック処理

* 既存スタックに合流可能（最大5体）
* 超える場合は新スタック生成

---

## 8. Endフェイズ（ターン終了）

### 8.1 勝利条件チェック

* 城数
* 石高
* 規定条件を満たした場合：

  * 即終了

### 8.2 ターンログ保存

* 入力
* 行動順
* 戦闘ログ
* HP変動
* 乱数消費量

---

## 9. このシステムの性質（設計上の要点）

* **低HPユニットが先に動く**
* **高HPユニットは強いが遅く、復活が遅い**
* 相性は絶対だが **戦力差で覆せる**
* 回復・強化は「時間差リスク」
* 同時入力でも **解決は完全決定的**
* 30ターン以内で必ず局面が動く

---




# スキル（特殊技能）システム仕様 v0.1（ターン処理へ統合）

## 1) 目的

* ユニットに任意のスキルを持たせ、戦術の幅を増やす
* ただし、同時入力・決定性・短時間（30T/1T=20〜60s）を壊さない

---

## 2) スキルの基本構造（データモデル）

各ユニットは **0個以上**のスキルを持てる。

スキルは以下を持つ：

* `skill_id`：識別子
* `trigger`：発動タイミング（後述）
* `chance`：発動確率（0〜1）または固定発動（1）
* `condition`：発動条件（例：HP%以下、城にいる、戦闘中など）
* `effect`：効果（例：回復、ダメージ増減、召喚補助、回復/強化短縮など）
* `cooldown`：再発動までのターン数（任意、0なら無し）
* `priority`：同タイミング内の解決順（小さいほど先）

> **決定性**のため、確率判定は必ず
> `seed + match_id + turn + phase + unit_id + skill_id + event_index`
> から導く乱数で行う（実装側ルール）。

---

## 3) 発動タイミング（あなたの要望を形式化）

「各フェーズのはじめと終わり」＝ **Trigger Point** を固定します。

### 3.1 フェーズとトリガー点

各ターンで、以下のトリガーを必ず呼ぶ：

* `START:Start`

* `END:Start`

* `START:Input`

* `END:Input`

* `START:Move`

* `END:Move`

* `START:Battle`

* `END:Battle`

* `START:Summon`

* `END:Summon`

* `START:End`

* `END:End`

> v0.1では「Input中に効果が出る」スキルは荒れやすいので、
> スキルの種類ごとに許可トリガーを制限する（後述）。

---

## 4) スキル判定の実行方法（決定性・公平性）

### 4.1 判定対象ユニット

各トリガー点で、**盤面に存在する全ユニット**（退場中を除く）に対して判定する。

* 退場中（respawn待ち）は判定しない
* 強化中（train中）は **判定はするが、攻撃/防衛に絡む効果は禁止**（効果カテゴリで制御）

### 4.2 判定順序（超重要）

トリガー点ごとに、判定順を固定：

1. **ユニットを unit_id 昇順**で並べる（決定性）
2. 各ユニットについて、該当トリガーのスキルを

   * `priority` 昇順
   * `skill_id` 昇順
     で処理
3. 各スキルで：

   * `cooldown` チェック
   * `condition` チェック
   * `chance` 判定（seed派生）
   * 発動なら `effect` を適用

---

## 5) 効果の適用ルール（衝突対策）

スキル効果は「いつ適用されるか」でバグりやすいので、v0.1は二層化します。

### 5.1 即時効果（Immediate）

* HP増減
* タイマー増減（回復/強化/復活の残りターンに +1/-1）
* 旗印（状態異常）付与：`stun`、`jam`、`shield` など

→ その場で即時適用して良い

### 5.2 遅延予約（Scheduled）

* 「次のMoveフェーズ開始時に〜」
* 「このターンのBattleフェーズ終了時に〜」

→ `scheduled_effects` に積んで、指定トリガーで確実に発火

> これで「途中で順序が変わって挙動が揺れる」問題を抑えます。

---

## 6) v0.1で許可するスキルカテゴリ（安全に広げる）

Input周辺や戦闘に直結するスキルは強すぎたり不具合が出やすいので、v0.1はカテゴリで制限します。

### 6.1 経済・時間差系（おすすめ）

* 回復タイマーを -1（ただし最低0）
* 強化タイマーを -1
* 召喚コストの一部返還（次ターンのみ有効）
* 産出+（そのターンのみ）

### 6.2 戦闘補助系（v0.1は控えめに）

* 自分の受けるダメージ -1（最低0）
* 相手のダメージ倍率を 1段階下げる（2→1、1→0）※ただし「戦力優位突破」は別判定
* 先制（Battle START時に1回だけ追加攻撃）※ログが増えるので注意

### 6.3 移動・制圧系

* Move START時に「このターンだけ移動距離+1」（※マップ仕様次第）
* 占領時に追加の金/資源（小）

### 6.4 禁止（v0.1では入れない）

* Inputフェーズで相手のコマンド内容を書き換える
* 盤面全体に影響する超広域スキル（テンポ崩壊）
* ランダム対象選択が多段に絡むもの（決定性が複雑化）

---

## 7) ターン処理への統合（最終フロー）

各フェーズはこうなります（※★がスキル判定ポイント）：

1. Start

   * ★START:Start（スキル）
   * 遅延タイマー更新（回復/強化/復活）
   * 完了処理（全回復/強化完了/復活配置）
   * ★END:Start（スキル）

2. Input

   * ★START:Input（スキル：基本は情報系/軽微のみ推奨）
   * 入力受付（同時）
   * ★END:Input（スキル）

3. Move

   * ★START:Move（スキル）
   * 低HP順に移動（同値seed）
   * 衝突で戦闘キューに登録
   * ★END:Move（スキル）

4. Battle

   * ★START:Battle（スキル）
   * 戦闘キュー処理（低HP順攻撃）
   * 退場処理・復活タイマー設定
   * ★END:Battle（スキル）

5. Summon

   * ★START:Summon（スキル）
   * 召喚予約を実行（移動後に出現）
   * スタック合流（最大5）
   * ★END:Summon（スキル）

6. End

   * ★START:End（スキル）
   * 勝利条件判定
   * ログ保存
   * ★END:End（スキル）

---

## 8) 最低限決めたいスキルデータ形式（JSON例）

```json
{
  "skill_id": "train_fast_1",
  "trigger": "START:Start",
  "chance": 0.25,
  "condition": { "self_status": "training" },
  "effect": { "kind": "decrease_timer", "target": "self", "timer": "train", "value": 1 },
  "cooldown": 0,
  "priority": 10
}
```

---

## 9) 追加で“必ず”必要になる設計（v0.1最小）

スキルを入れると、必須で以下をStateに持つ必要があります：

* `unit.statuses`（training/healing 等）
* `unit.cooldowns`（skill_id→remaining）
* `scheduled_effects`（発火待ち効果）
* `rng_event_index`（ログ用：乱数消費の追跡）

---
